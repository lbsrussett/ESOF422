model Iterator

-- classes

abstract class Aggregate
attributes
operations
	createIterator()
	
end

class ConcreteAggregate < Aggregate
attributes
	name : String init : 'Collection';
	numObjects : Real init : 0
	items: Set(Item);
operations
	addToSet() : Set(Item)
		begin
			self.numObjects:=self.items->size();
			for i in self.items do 
				item:=new Item;
				self:=items->including(item);
			end
			end
			result:=self.items;
		--end
	end

	createIterator() : Iterator

	begin
		declare iterator : Iterator;
		iterator.objects := self.items;
	-- 	for n in self.numObjects do
	--		ca := new ConcreteAggregate;
	--		iterator.objects->including(ca);
	--	end 	
	end
	
	beginIterate() : Aggregate
	begin
	--	for o in self.objects do
	--		result := o;
	--	end
	end

end

class Item 
attributes
	name : String;
end

abstract class Iterator 
attributes
	hasNext: Boolean;
	objects: Set(Aggregate);

operations
	next() : Aggregate
	hasNext() : Boolean

end

class ConcreteIterator < Iterator
attributes
	name : String;
	
operations
	next() : ConcreteAggregate
	hasNext() : Boolean
	
end

class Client
attributes 
	name : String init : 'Clem'
operations		
end

-- associations

association clientAg between
	Client [1] role client
	Aggregate [1] role agg
end

association clientIt between
	Client [1] role client
	Iterator [1] role iter
end

association creates between
	ConcreteAggregate [1] role collection
	ConcreteIterator [1] role iter
end

-- constraints

constraints

--context ConcreteAggregate::items : Set(Aggregate) 
--init: Set{};

context ConcreteAggregate::createIterator()
	pre createIterPre: not iter.isDefined()
	post createIterPost: iter.isDefined()

--not sure how to make condition based on operation value
context ConcreteIterator::next(): ConcreteAggregate
	pre nextPre: hasNext = true
	--post: none

context ConcreteIterator::hasNext(): Boolean
	pre hasNextPre: collection.isDefined()
	--post: none


